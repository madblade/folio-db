{"title":"Nearest neighbors matrix","author":"","type":"technical","date":"2024/11/27","thumb":"","body":[{"type":0,"content":""},{"type":2,"content":"In 2014, I was asked to benchmark a few unsupervised clustering algorithms, such as k-means, soft k-means, k-medoids, HAC with different linkages, etc. Among these methods, there was the exotic <a href=\"https://patents.google.com/patent/US6295504B1/en\">Multi-Resolution Graph-Based Clustering</a> (MRGC)."},{"type":2,"content":"like <a href=\"https://en.wikipedia.org/wiki/DBSCAN\">DBSCAN</a>, the difference with k-means is that it does not require the user to specify the number of clusters <em>a priori</em>. It is inspired by an earlier method by <a href=\"https://www.gretsi.fr/data/colloque/pdf/1991_017-0023_11628.pdf\">Changquan Gan</a>, based on using nearest neighbors. The patent expired in 2020, so there were not many implementations available at the time."},{"type":2,"content":"The algorithm itself is not particularly difficult to implement, but it is a bit tedious since there are many steps compared to other simple clustering algorithms. One of the initial stages is to compute a rank matrix."},{"type":2,"content":"Suppose we have <small>$n$</small> points in space. These points are indexed from <small>$1$</small> to <small>$n$</small>. The rank matrix that we want to build is denoted <small>$C$</small>. It contains, for every point, the rank of this point in every other point’s neighborhood. These ranks are ordered in the neighborhood of the starting point. In other words, <small>$C[i][j]$</small> is the rank of <small>$i$</small> in the neighborhood of its <small>$j^{th}$</small> neighbor."},{"type":2,"content":"By convention, each point is considered to be its own <small>$n^{th}$</small> nearest neighbor. So, if I have three points <small>$P_1$</small>, <small>$P_2$</small>, <small>$P_3$</small>, then the 3-by-3 rank matrix will give me at row 1, column 1, the rank of <small>$P_1$</small> in the neighborhood of its closest point. If <small>$P_1$</small>’s closest neighbor is <small>$P_2$</small>, but <small>$P_2$</small>’s closest neighbor is <small>$P_3$</small>, then that value will be 2."},{"type":2,"content":"To build this matrix <small>$C$</small>, the authors propose the following method: first, compute the matrix <small>$A$</small>, where <small>$A[i][j]$</small> is the index of the <small>$j^{th}$</small> neighbor of point <small>$i$</small>."},{"type":7,"content":"A=\\begin{bmatrix}\n5 & 2 & 6 & 4 & 3 & 1 \\\\\n4 & 6 & 3 & 1 & 5 & 2 \\\\\n6 & 1 & 5 & 2 & 4 & 3 \\\\\n1 & 3 & 2 & 5 & 6 & 4 \\\\\n6 & 2 & 4 & 3 & 1 & 5 \\\\\n2 & 3 & 1 & 4 & 5 & 6 \\\\\n\\end{bmatrix}\n"},{"type":2,"content":"Then, build an intermediate matrix <small>$B$</small>, that contains the simple ascending sequence of integers in every row. Now sort every row of <small>$A$</small>, and modify every row of <small>$B$</small> in the same way as rows of <small>$A$</small> are modified during the sort. We’ll work with a copy of <small>$A$</small> because we’ll need it again later."},{"type":7,"content":"B_0=\\begin{bmatrix}\n1 & 2 & 3 & 4 & 5 & 6 \\\\\n1 & 2 & 3 & 4 & 5 & 6 \\\\\n1 & 2 & 3 & 4 & 5 & 6 \\\\\n1 & 2 & 3 & 4 & 5 & 6 \\\\\n1 & 2 & 3 & 4 & 5 & 6 \\\\\n1 & 2 & 3 & 4 & 5 & 6 \\\\\n\\end{bmatrix}\n"},{"type":2,"content":"Which is transformed to:"},{"type":7,"content":"B=\\begin{bmatrix}\n6 & 2 & 5 & 4 & 1 & 3 \\\\\n4 & 6 & 3 & 1 & 5 & 2 \\\\\n2 & 4 & 6 & 5 & 3 & 1 \\\\\n1 & 3 & 2 & 6 & 4 & 5 \\\\\n5 & 2 & 4 & 3 & 6 & 1 \\\\\n3 & 1 & 2 & 4 & 5 & 6 \\\\\n\\end{bmatrix}\n"},{"type":2,"content":"The entry <small>$B[k][i]$</small> then gives the rank of <small>$i$</small> relative to <small>$k$</small>."},{"type":2,"content":"But, since the index of the <small>$j^{th}$</small> nearest neighbor of <small>$i$</small> is <small>$A[i][j]$</small>, we can trivially build <small>$C$</small> by replacing <small>$k$</small> like so: <small>$C[i][j] = B[A[i][j]][i]$</small>."},{"type":7,"content":"C=\\begin{bmatrix}\n5 & 4 & 3 & 1 & 2 & 6 \\\\\n3 & 1 & 4 & 2 & 2 & 6 \\\\\n2 & 5 & 4 & 3 & 2 & 6 \\\\\n4 & 5 & 1 & 3 & 4 & 6 \\\\\n5 & 5 & 4 & 3 & 1 & 6 \\\\\n2 & 1 & 3 & 5 & 1 & 6 \\\\\n\\end{bmatrix}\n"},{"type":2,"content":"Remember that by convention, each point is considered to be its own <small>$n^{th}$</small> nearest neighbor."},{"type":2,"content":"I was bothered by this storting step. I found it weird to have a quasilinear processing of rows there when every other manipulation was linear. The definition of the matrix <small>$C$</small> itself sounded linear, so the sort really didn’t feel justified. I took a closer look at the rank matrices."},{"type":2,"content":"After a bit of fiddling around, I realized that <small>$B[i][A[i][j]] = j$</small>. In other words, the rank of <small>$A[i][j]$</small> relative to <small>$i$</small> is <small>$j$</small>. Which is the definition of <small>$A$</small>. That makes this part of the algorithm linear: we just have to loop over <small>$j$</small> for a fixed <small>$i$</small>, and the corresponding row of the matrix <small>$B$</small> will be filled in linear time."},{"type":2,"content":"Why is it not obvious to the eye that these manipulations on ranks can be simplified? I think the answer is that we are manipulating different entities here: ranks and indices, which both conveniently happen to be unsigned integers, and both happen to take all values between 1 and n. So the idea to use them interchangeably does not come naturally. Another possibility is that these manipulations on indices do not carry the initial intuition behind the approach, which is that if we want to manipulate indexing methods, there has to be some form of sorting involved."},{"type":2,"content":"After I found this opportunity for optimization in the patent and told pepople about it, no one really seemed to care, and it ended not being implemented anywhere. Now, to be fair, even if there are interesting gains in terms of memory because we don’t need to use a companion array for the sorting, there will be a lot of cache misses because we are reading from <small>$A$</small> at random. But still! we could have saved a sort in a tight loop."},{"type":2,"content":"What lessons can we learn from this? First, I’d say that once a complex approach has been engineered, it is hard for people to accept to come back to it later to understand it and optimize it, and the main reason for that is that we are cost-driven. Another of the offenders is the lack of time spent working on the approach, with patents lacking the peer-review process, although it can also be true of peer-reviewed papers with tight deadlines."},{"type":2,"content":"In the context of game engines in particular, the cost-driven approach to development is widespread. Ironically, there is a high cost to that approach, in terms of technical debt, loss of knowledge, and loss of efficiency, that has often been neglected in competitive industries."}],"id":30002}