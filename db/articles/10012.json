{"title":"Minecraft with Portals in WebGL","date":"2020/06/20","author":"M. S","thumb":"assets/img/craft/spix-portals.jpg","body":[{"type":4,"content":"assets/img/craft/spix-portals.jpg"},{"type":2,"content":"This small WebGL project is a javascript minecraft clone prototype with portals, generic gravity, multiplayer sandbox, and other basic effects, based on ThreeJS. The nature of javascript, its design and especially the JIT runtime, make it extremely fast to get a basic idea running and then to iterate. Browsers also provide out-of-the-box profilers and debugging tools. This greatly reduces the time spent on debugging or investigating low-level technical details irrelevant to prototyping."},{"type":2,"content":"<a href=\"https://madblade.github.io/spix/\">Demo</a>"},{"type":2,"content":"<a href=\"https://github.com/madblade/spix/\">Source code</a>"},{"type":0,"content":"Some technical challenges"},{"type":2,"content":"<b>Texture bleeding</b>: using atlasing with texture filtering (linear mipmapping or anisotropic filtering) will produce bleeding artifacts on the edge of block tiles, because linear filters query neighbor tiles. At the time I worked on this, in WebGL, anisotropic filtering was performed by an extension called <i>EXT_texture_filter_anisotropic</i>, for which:"},{"type":6,"content":"Implementations are (…) permitted to ignore the minification or magnification filter and implement the highest quality of anisotropic filtering possible. Applications seeking the highest quality anisotropic filtering available are advised to request a LINEAR_MIPMAP_LINEAR minification filter, a LINEAR magnification filter, and a large maximum degree of anisotropy.","origin":"","source":""},{"type":2,"content":"This means that the magnification filter is most likely LINEAR (where we want NEAREST). If we don’t really care about bleeding in the distance at grazing angles, we certainly do care about having sharp, pixelated, minecraft-like textures when they’re magnified, and we want to keep them as small as they should be. Without much control on how anisotropic filtering combines mipmaps in WebGL, I just disabled anisotropic filtering and only used nearest filters. This produces ugly grain at the distance. The other workaround to the bleeding edges artifact would be to add padding each atlas tile, like in virtual texturing, but this requires a constant 1-pixel pad for all mips, and since WebGL does not have compute shaders, there is no viable option for mip generation other than the default one (without pads)."},{"type":2,"content":"<b>Portals</b>: performance and flexibility. Using render target textures (RTTs) is a flexible solution for rendering nested portals (and allows me to further apply distortion effects if I want), at the cost of performance. The other well-documented technique, that uses stencil masks, offers performance at the cost of being somewhat less flexible and more programmatically involved. Here I somewhat combined the advantages of both: first, rendering a scene that contains only the portal frame to the stencil buffer, then rendering the “otherworldly” scene into an RTT using the stencil buffer to restrict the screen space needing rasterization. There is a neat performance gain over only using RTTs! In Threejs, however, this comes with a drawback: there is no default anti-aliasing for rendering to textures, so I needed an additional software FXAA pass."},{"type":2,"content":"Edit (2024/11): this excellent <a href=\"https://www.youtube.com/watch?v=w-Z1Fx0LvDc\">Psychonauts 2 talk</a> mentions a few other technical points related to seamless portals, including one that I also implemented at the time from a discussion with Tom Hulton: culling with an oblique view frustum."},{"type":2,"content":"<b>Performance issues, I</b>: in a browser, performance is a major bottleneck. When a CPU task cannot be completed in less than 7ms (for 144Hz displays), it must be made progressive (which means, it must pause when its time budget has been exhausted, only to resume at the next game loop iteration). Having algorithms work in a streaming manner (and caching their work) is necessary for the terrain generation part, as well as for some topological algorithms that run there."},{"type":2,"content":"<b>Performance issues, II</b>: because of the generality of ThreeJS, it is necessary to use instancing for materials when rendering a given scene from multiple cameras in a single frame, which is the case for portals and water reflection. Without instancing materials and swapping between them after each render call, ThreeJS used to automatically recompile them because it thought that the lighting had changed. It was not storing the appropriate shader permutation key. This has been addressed a while ago by the ThreeJS people, but there are many other performance concerns with the way ThreeJS does things lazily. For examile, shader compilation warmups for all the material permutations and light configurations are not possible if we don’t know the exact lighting setup of every scene beforehand."},{"type":2,"content":"<b>Multiplayer</b>: network bandwidth and latency are major bottlenecks that make it key to think about the project architecture from the start. Here I am using a simple lockstep model, only transmitting client inputs and world updates, but because of the SocketIO/TCP overhead, I found that client interpolation was necessary. An advantage of doing everything in javascript is that I can easily bundle the server and the client together—and launch the game locally in the browser. This is what is done in the demo, where the default game setting has the client running as fast as the display can handle, while the server is sending entity updates at 20Hz."},{"type":2,"content":"This project came with other challenges (physics, crisp shadows, skies, terrain generation…) that I could talk about in more detail."},{"type":0,"content":"Gallery"},{"type":4,"content":"assets/img/craft/spix-scene.jpg"},{"type":4,"content":"assets/img/craft/spix-shadows.jpg"},{"type":5,"image1":"assets/img/craft/spix-cube.jpg","image2":"assets/img/craft/spix-portals.jpg"},{"type":4,"content":"assets/img/craft/spix-demo-1.gif"},{"type":4,"content":"assets/img/craft/spix-demo-2.gif"},{"type":4,"content":"assets/img/craft/spix-demo-3.gif"}],"type":"craft","id":10012}