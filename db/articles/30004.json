{"title":"Secretely optimizing a patented algorithm","author":"","type":"technical","date":"2024/11/27","thumb":"","body":[{"type":0,"content":""},{"type":2,"content":"Ten years ago, I was asked to benchmark a few unsupervised clustering algorithms, like k-means, soft k-means, k-medoids, HAC with different linkages, etc. Among these methods, there was one that I had never heard about: <a href=\"https://patents.google.com/patent/US6295504B1/en\">Multi-Resolution Graph-Based Clustering</a> (MRGC)."},{"type":2,"content":"The difference with k-means is that it does not require the user to specify the number of clusters <em>a priori</em>, like <a href=\"https://en.wikipedia.org/wiki/DBSCAN\">DBSCAN</a>. It is inspired by an earlier method by <a href=\"https://www.gretsi.fr/data/colloque/pdf/1991_017-0023_11628.pdf\">Changquan Gan</a>, based on using nearest neighbors. The patent expired in 2020, so there weren’t many implementations available at the time."},{"type":2,"content":"The algorithm itself is not particularly difficult to implement, but it is a bit tedious since there are many steps compared to other simple clustering algorithms. One of the initial stages is to compute a rank matrix."},{"type":2,"content":"Suppose we have <small>$n$</small> points in space. These points are indexed from <small>$1$</small> to <small>$n$</small>. The rank matrix that we want to build is denoted <small>$C$</small>. It contains, for every point, the rank of this point in every other point’s neighborhood. These ranks are ordered in the neighborhood of the starting point. In other words, <small>$C[i][j]$</small> is the rank of <small>$i$</small> in the neighborhood of its <small>$j^{th}$</small> neighbor."},{"type":2,"content":"To build this matrix <small>$C$</small>, the authors propose the following method: first, compute the matrix <small>$A$</small>, where <small>$A[i][j]$</small> is the index of the <small>$j^{th}$</small> neighbor of point <small>$i$</small>."},{"type":7,"content":"A=\\begin{bmatrix}\n5 & 2 & 6 & 4 & 3 & 1 \\\\\n4 & 6 & 3 & 1 & 5 & 2 \\\\\n6 & 1 & 5 & 2 & 4 & 3 \\\\\n1 & 3 & 2 & 5 & 6 & 4 \\\\\n6 & 2 & 4 & 3 & 1 & 5 \\\\\n2 & 3 & 1 & 4 & 5 & 6 \\\\\n\\end{bmatrix}\n"},{"type":2,"content":"Then, build an intermediate matrix <small>$B$</small>, that contains the simple ascending sequence of integers in every row. Now sort every row of <small>$A$</small>, and modify every row of <small>$B$</small> in the same way as rows of <small>$A$</small> are modified during the sort. We’ll work with a copy of <small>$A$</small> because we’ll need it again later."},{"type":7,"content":"B_0=\\begin{bmatrix}\n1 & 2 & 3 & 4 & 5 & 6 \\\\\n1 & 2 & 3 & 4 & 5 & 6 \\\\\n1 & 2 & 3 & 4 & 5 & 6 \\\\\n1 & 2 & 3 & 4 & 5 & 6 \\\\\n1 & 2 & 3 & 4 & 5 & 6 \\\\\n1 & 2 & 3 & 4 & 5 & 6 \\\\\n\\end{bmatrix}\n"},{"type":2,"content":"Which is transformed to:"},{"type":7,"content":"B=\\begin{bmatrix}\n6 & 2 & 5 & 4 & 1 & 3 \\\\\n4 & 6 & 3 & 1 & 5 & 2 \\\\\n2 & 4 & 6 & 5 & 3 & 1 \\\\\n1 & 3 & 2 & 6 & 4 & 5 \\\\\n5 & 2 & 4 & 3 & 6 & 1 \\\\\n3 & 1 & 2 & 4 & 5 & 6 \\\\\n\\end{bmatrix}\n"},{"type":2,"content":"The entry <small>$B[k][i]$</small> then gives the rank of <small>$i$</small> relative to <small>$k$</small>."},{"type":2,"content":"But, since the index of the <small>$j^{th}$</small> nearest neighbor of <small>$i$</small> is <small>$A[i][j]$</small>, we can trivially build <small>$C$</small> by replacing <small>$k$</small> like so: <small>$C[i][j] = B[A[i][j]][i]$</small>."},{"type":7,"content":"C=\\begin{bmatrix}\n5 & 4 & 3 & 1 & 2 & 6 \\\\\n3 & 1 & 4 & 2 & 2 & 6 \\\\\n2 & 5 & 4 & 3 & 2 & 6 \\\\\n4 & 5 & 1 & 3 & 4 & 6 \\\\\n5 & 5 & 4 & 3 & 1 & 6 \\\\\n2 & 1 & 3 & 5 & 1 & 6 \\\\\n\\end{bmatrix}\n"},{"type":2,"content":"Note that by convention, each point is considered to be its own <small>$n^{th}$</small> nearest neighbor."},{"type":2,"content":"End of the story. …or is it?"},{"type":2,"content":"The actual story is that I was sort of bothered by the storting step. I found it weird to have a quasilinear processing of rows there when every other manipulation was linear. The definition of the matrix <small>$C$</small> itself sounded linear, so the sort really didn’t feel justified. So I took a closer look to the rank matrices."},{"type":2,"content":"After a bit of fiddling around, I realized that <small>$B[i][A[i][j]] = j$</small>. In other words, the rank of <small>$A[i][j]$</small> relative to <small>$i$</small> is <small>$j$</small>. Which is the definition of <small>$A$</small>. That makes this part of the algorithm linear: we just have to loop over <small>$j$</small> for a fixed <small>$i$</small>, and the corresponding row of the matrix <small>$B$</small> will be filled in linear time."},{"type":2,"content":"After a while I asked myself, why bother with the sorting in the first place? Why is it not obvious to the eye that these manipulations on ranks can be simplified? I think the answer is that we are manipulating different entities here: ranks and indices, which both conveniently happen to be unsigned integers, and both happen to take all values between 1 and n. So the idea to use them interchangeably does not come naturally. Another possibility is that these manipulations on indices do not carry the initial intuition behind the approach, which is that if we want to manipulate indexing methods, there has to be some form of sorting involved."},{"type":2,"content":"But, you might ask, what about the secrecy? Well, the complete story is that after I found this opportunity for optimization in the patent and told pepople about it, no one really seemed to care, and it ended not being implemented anywhere. So it really might be a secret optimization that nobody likely knows about, at least in the context of MRGC."},{"type":2,"content":"Now, to be fair, I didn’t measure the performance delta at the time. Even if there are big gains in terms of memory because we don’t need to use a companion array for the sorting, there will be a lot of cache misses because we are reading from <small>$A$</small> at random."}],"id":30004}