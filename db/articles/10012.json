{"title":"WebGL and lightspeed prototyping: Minecraft with Portals","date":"2020/06/20","author":"M. S","thumb":"assets/img/craft/spix-portals.jpg","body":[{"type":4,"content":"assets/img/craft/spix-portals.jpg"},{"type":2,"content":"Once I thought I’d grow tired of Minecraft because of cosmetic updates (more blocks, more effects, more mobs, more <i>things</i> and not more things <i>to do</i>), but this was before the Combat Update. Regardless of whether people agree or not with the design choices of this update, it was assuming a direction, restricting the range of possibilities rather than opening it. This somehow made me nostalgic of the Redstone Update, which provided players with something they needed—but they didn’t know they needed. "},{"type":2,"content":"This small WebGL project shows that it is quite easy (even for a single person) to prototype simple ideas (even for a multiplayer sandbox game), like portals, generic gravity, basic effects; and to experiment, to grow as a person interested in graphics and game development, while keeping the possibilities open. The nature of the JavaScript ecosystem make it <i>really</i> fast to get a basic idea working and to debug—less than two seconds from the moment you hit Ctrl+S to your browser reloading with the project running up-to-date; out-of-the-box profilers and development tools, lots of support. This greatly reduces the time spent on debugging or investigating low-level technical details irrelevant to prototyping."},{"type":2,"content":"Edit: more will be said about iteration speed and performance in a later article."},{"type":2,"content":"<a href=\"https://madblade.github.io/spix/\">Demo</a>"},{"type":2,"content":"<a href=\"https://github.com/madblade/spix/\">Source code</a>"},{"type":0,"content":"Some technical challenges"},{"type":2,"content":"<b>Texture bleeding</b>: using atlasing with texture filtering (linear mipmapping or anisotropic filtering) will produce bleeding artifacts on the edge of block tiles, because linear filters query neighbor tiles. At the time I worked on this, in WebGL, anisotropic filtering was performed by an extension called <i>EXT_texture_filter_anisotropic</i>, for which:"},{"type":6,"content":"Implementations are (…) permitted to ignore the minification or magnification filter and implement the highest quality of anisotropic filtering possible. Applications seeking the highest quality anisotropic filtering available are advised to request a LINEAR_MIPMAP_LINEAR minification filter, a LINEAR magnification filter, and a large maximum degree of anisotropy.","origin":"","source":""},{"type":2,"content":"This means that the magnification filter is most likely LINEAR (where we want NEAREST). If we don’t <i>really</i> care about bleeding in the distance at grazing angles, we certainly do care about having sharp, pixelated, minecraft-like textures when they’re magnified, and we want to keep them as small as they should be. Without much control on how anisotropic filtering combines mipmaps in WebGL, I had little choice but to disable anisotropic filtering and only use nearest filters. That produces (ugly) grain at oblique viewing angles."},{"type":2,"content":"<b>Portals</b>: performance and flexibility. Using render target textures (RTTs) is a flexible solution for rendering nested portals (and allows us to further apply distortion effects if we want), at the cost of performance. The other well-documented technique, that uses stencil masks, offers performance at the cost of being somewhat less flexible and more programmatically involved. Here we somewhat combine the advantages of both: first, rendering a scene that contains only the portal frame to the stencil buffer, then rendering the “otherworldly” scene into an RTT using the stencil buffer to restrict the screen space needing rasterization. There is a neat performance gain over only using RTTs! In Threejs, however, this comes with a drawback: there is no default anti-aliasing for rendering to textures, hence the need for an additional software FXAA pass."},{"type":2,"content":"Edit (2024/11): this excellent <a href=\"https://www.youtube.com/watch?v=w-Z1Fx0LvDc\">Psychonauts 2 talk</a> mentions a few other technical points related to seamless portals, including one that I also implemented at the time: culling with an oblique view frustum."},{"type":2,"content":"<b>Performance issues, I</b>: in a browser, performance is a major bottleneck. When a CPU task cannot be completed in less than 7ms (for 144Hz displays), it must be made progressive (which means, it must pause when its time budget has been exhausted, only to resume at the next game loop iteration). Having algorithms work in a streaming manner (and caching their work) is necessary for the terrain generation part, as well as for some topological algorithms that run there."},{"type":2,"content":"<b>Performance issues, II</b>: the clock provided by the JavaScript function <i>performance.now()</i> was accurate to 5µs, before Spectre and Meltdown. Since then, for security reasons, the resolution of timers has been decreased, and the support for SharedArrayBuffer has been dropped by many browsers, greatly limiting the advantages WebWorkers could have. (Edit 2024/11 - shared arrays have been back for a while, but this should serve as a warning: browsers tend to auto-update frequently and may well deploy breaking changes for your application if you rely on too many APIs)"},{"type":2,"content":"<b>Performance issues, III</b>: because of the generality of Threejs, it is necessary to use instancing for materials when rendering a scene from multiple cameras in a single frame (that’s the case for portals and water reflection). Without instancing materials and swapping between them after each render call, Threejs automatically rebuilds them (because it thinks the lighting has changed), greatly increasing the CPU load and inducing a performance drop, which is most noticeable in Firefox. (Edit 2024/11 - this has been addressed a while ago by the Three folks, but there are many other performance concerns, such as shader compilation warmups that are difficult to do for all the material permutations and light configurations if we don’t know them beforehand)"},{"type":2,"content":"<b>Performance issues, IV</b>: before getting started on a multiplayer-oriented project, it’s important to have a clear idea of what kind of a game model is suitable for that case. Network bandwidth and latency are major bottlenecks that makes it key to think about the project’s architecture from the start. Here I’m using a lockstep model (only transmitting client inputs and world updates), but because of the SocketIO/TCP overhead, I found that client interpolation was necessary. Another advantage of doing everything in JavaScript (NodeJS + ES6) is that I can easily bundle the server and the client together—and launch the game locally in the browser. This is what was done in the demo, where the default game settings has the client running as fast as the display can handle (bound to the display refresh rate), and the server is sending entity updates at 20Hz. "},{"type":2,"content":"This project came with many other challenges (e.g. physics, shadows, skies…) that I’d be happy to talk about in a next article."},{"type":0,"content":"Gallery"},{"type":4,"content":"assets/img/craft/spix-scene.jpg"},{"type":4,"content":"assets/img/craft/spix-shadows.jpg"},{"type":5,"image1":"assets/img/craft/spix-cube.jpg","image2":"assets/img/craft/spix-portals.jpg"},{"type":4,"content":"assets/img/craft/spix-demo-1.gif"},{"type":4,"content":"assets/img/craft/spix-demo-2.gif"},{"type":4,"content":"assets/img/craft/spix-demo-3.gif"}],"type":"craft","id":10012}